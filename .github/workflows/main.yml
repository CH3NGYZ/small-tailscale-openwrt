name: Sync and Build Tailscale

on:
  schedule:
    - cron: '10 23 * * *'
  workflow_dispatch:
    inputs:
      versions:
        description: 'Tailscale versions (e.g. 1.76.1-1.78.0,1.79.2 — leave empty for latest)'
        required: false
  watch:
    types: [started]

permissions:
  contents: write

env:
  REPO_OFFICIAL: 'tailscale/tailscale'
  BUILD_PLATFORMS: 'amd64 386 arm arm64 mips mipsle mips64 mips64le'
  GO_BUILD_FLAGS: "-tags ts_include_cli -ldflags='-s -w'"

jobs:
  prepare_versions:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set_matrix.outputs.matrix }}
    steps:
      - name: Fetch all tags from official repo
        id: fetch_tags
        run: |
          curl -s "https://api.github.com/repos/${{ env.REPO_OFFICIAL }}/tags?per_page=1000" | \
            jq -r '.[].name' | grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+$' > all_tags.txt

      - name: Parse user input and build matrix
        id: set_matrix
        run: |
          echo "===> 输入参数: ${{ github.event.inputs.versions }}"
          input="${{ github.event.inputs.versions }}"

          if [ -z "$input" ]; then
            tag=$(head -n1 all_tags.txt)
            tag=${tag#v}  # 去除前缀 v（如果有）
            echo "未提供输入，默认取第一个 tag: $tag"
            echo "matrix=$(jq -cn --arg v "$tag" '[ $v ]')" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "===> 开始解析版本范围：$input"

          declare -A versions
          IFS=',' read -ra parts <<< "$input"
          for part in "${parts[@]}"; do
            if [[ "$part" == *"-"* ]]; then
              start=${part%-*}
              end=${part#*-}
              echo "  发现范围: $start 到 $end"
              matched=$(sed 's/^v//' all_tags.txt | sort -V | awk -v s="$start" -v e="$end" '$0 >= s && $0 <= e')
              echo "    匹配结果：$(echo "$matched" | xargs)"
              for v in $matched; do
                versions["v$v"]=1
              done
            else
              echo "  发现单一版本: $part"
              versions["v$part"]=1
            fi
          done

          echo "===> 收集到版本（未排序）:"
          for v in "${!versions[@]}"; do
            echo "  - $v"
          done

          all_versions_sorted=$(for v in "${!versions[@]}"; do echo "$v" | sed 's/^v//'; done | sort -V)
          echo "===> 排序后版本:"
          echo "$all_versions_sorted"

          jq_array=$(printf '%s\n' $all_versions_sorted | jq -R . | jq -s .)
          echo "===> 生成 matrix:"
          echo "$jq_array" | jq -c
          echo "matrix=$(echo "$jq_array" | jq -c)" >> "$GITHUB_OUTPUT"

  build_and_release:
    needs: prepare_versions
    runs-on: ubuntu-latest
    strategy:
      matrix:
        version: ${{ fromJson(needs.prepare_versions.outputs.matrix) }}
      fail-fast: true
      max-parallel: 16
    env:
      TAG: v${{ matrix.version }}
    steps:
      - name: Check if release exists
        id: check_release
        run: |
          REPO="${{ github.repository }}"
          TAG="v${{ matrix.version }}"
          TOKEN="${{ secrets.GITHUB_TOKEN }}"

          # 查询 Release
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: token $TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$REPO/releases/tags/$TAG")

          if [ "$RESPONSE" -eq 200 ]; then
            echo "Release $TAG already exists"
            echo "skip=true" >> $GITHUB_ENV
          else
            echo "Release $TAG does not exist"
            echo "skip=false" >> $GITHUB_ENV
          fi

      - name: Checkout Tailscale source
        uses: actions/checkout@v4
        if: env.skip != 'true'
        with:
          repository: ${{ env.REPO_OFFICIAL }}
          ref: ${{ env.TAG }}

      - name: Setup Go environment
        uses: actions/setup-go@v5
        if: env.skip != 'true'
        with:
          go-version: 'stable'

      - name: Install latest UPX
        if: env.skip != 'true'
        run: |
          set -e
          LATEST_UPX=$(curl -s https://api.github.com/repos/upx/upx/releases/latest | grep -oP '"tag_name": "v\K[0-9.]+' | head -n1)
          echo "Latest UPX version: $LATEST_UPX"
          curl -LO "https://github.com/upx/upx/releases/download/v${LATEST_UPX}/upx-${LATEST_UPX}-amd64_linux.tar.xz"
          tar -xf "upx-${LATEST_UPX}-amd64_linux.tar.xz"
          sudo cp "upx-${LATEST_UPX}-amd64_linux/upx" /usr/local/bin/
          upx --version

      - name: Build optimized binaries
        if: env.skip != 'true'
        run: |
          echo "${{ env.TAG }}" > version.txt
          mkdir -p ./build
          for arch in ${{ env.BUILD_PLATFORMS }}; do
            echo "Building for $arch..."
            binary_name="./build/tailscaled-linux-${arch}.build"

            export CGO_ENABLED=0
            export GOOS=linux
            export GOARCH=$arch

            case "$arch" in
              mips|mipsle)
                export GOMIPS=softfloat
                ;;
            esac

            go build -o "$binary_name" ${{ env.GO_BUILD_FLAGS }} ./cmd/tailscaled

            if [ ! -f "$binary_name" ]; then
              echo "❌  编译失败: $binary_name 不存在"
              exit 1
            fi
          done

      - name: Compress binaries
        if: env.skip != 'true'
        run: |
          mkdir -p ./upx_compress
          for arch in ${{ env.BUILD_PLATFORMS }}; do
            binary_name="./build/tailscaled-linux-${arch}.build"
            compressed_name="./upx_compress/tailscaled-linux-${arch}"

            case "$arch" in
              mips64|mips64le)
                echo "⚠️  跳过 $arch 的 UPX 压缩"
                cp "$binary_name" "$compressed_name"
                ;;
              *)
                if [[ -f "$binary_name" ]]; then
                  upx --lzma --best --no-progress "$binary_name" -o "$compressed_name"
                else
                  echo "❌  编译失败: $binary_name 不存在"
                fi
                ;;
            esac
          done

      - name: Generate checksums
        if: env.skip != 'true'
        run: |
          sha256sum ./build/tailscaled-* > SHA256SUMS.txt
          md5sum ./build/tailscaled-* > MD5SUMS.txt
          sha256sum ./upx_compress/tailscaled-* >> SHA256SUMS.txt
          md5sum ./upx_compress/tailscaled-* >> MD5SUMS.txt

          sed -i 's|./build/||g' SHA256SUMS.txt
          sed -i 's|./build/||g' MD5SUMS.txt
          sed -i 's|./upx_compress/||g' SHA256SUMS.txt
          sed -i 's|./upx_compress/||g' MD5SUMS.txt
          sed -i 's/  */ /g' SHA256SUMS.txt
          sed -i 's/  */ /g' MD5SUMS.txt

          cat SHA256SUMS.txt
          cat MD5SUMS.txt

      - name: Wait previous version release
        if: env.skip != 'true'
        run: |
          echo "=== 当前 Matrix 版本列表 ==="
          echo '${{ needs.prepare_versions.outputs.matrix }}' | jq -r '.[]'

          # 解析 matrix 为 bash 数组
          readarray -t matrix_versions < <(echo '${{ needs.prepare_versions.outputs.matrix }}' | jq -r '.[]')

          # 找出当前版本在 matrix 中的前一个版本
          prev_version=""
          for i in "${!matrix_versions[@]}"; do
            if [ "${matrix_versions[$i]}" == "${{ matrix.version }}" ]; then
              if [ $i -gt 0 ]; then
                prev_version="${matrix_versions[$i-1]}"
              fi
              break
            fi
          done

          if [ -z "$prev_version" ]; then
            echo "当前版本是最早版本，无需等待，直接发布 ${{ matrix.version }}"
            exit 0
          fi

          echo "当前版本之前的 Matrix 版本: $prev_version"

          # 循环等待，直到该版本 release 已存在
          until curl -s -f "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/v$prev_version" >/dev/null 2>&1; do
            echo "⏳ 等待前一个版本 v$prev_version 的 release 创建..."
            sleep 5
          done

          echo "✅ 前一个版本 v$prev_version 的 release 已存在 — 可以发布当前版本 ${{ matrix.version }}"

      - name: Create Release
        uses: softprops/action-gh-release@v1
        if: env.skip != 'true'
        with:
          tag_name: ${{ env.TAG }}
          name: 'Tailscale ${{ env.TAG }}'
          body: |
            ## 🚀 Tailscale ${{ env.TAG }} UPX压缩版发布

            [![Downloads](https://img.shields.io/github/downloads/CH3NGYZ/small-tailscale-openwrt/${{ env.TAG }}/total)](https://github.com/CH3NGYZ/small-tailscale-openwrt/releases/${{ env.TAG }})

            🧩 **支持架构**：
            `${{ env.BUILD_PLATFORMS }}`

            ⚙️  **内容说明**：
            - 每个架构只生成一个联合二进制文件，通过改名即可分别作为`tailscale`（前台程序）和`tailscaled`（后台程序）运行。
            - *注意：由于 UPX[目前不支持, 也没有计划支持](https://github.com/upx/upx/issues/272#issuecomment-1250010942)`mips64`与`mips64le`架构, 此release中这两个架构的可执行文件为`未压缩`的状态*

            📄 **校验方式**：
            把 tailscale-linux-* 和校验文件放在同一个目录下，执行：
            ```bash
            sha256sum -c SHA256SUMS.txt
            md5sum -c MD5SUMS.txt
            ```

            🔧  **快速启动**：
            ```bash
            chmod +x /path/to/tailscaled-linux-amd64
            ln -s /path/to/tailscaled-linux-amd64 /usr/bin/tailscale
            ln -s /path/to/tailscaled-linux-amd64 /usr/bin/tailscaled
            tailscaled & # 服务进程需后台运行
            tailscale up # 等待服务进程运行几秒之后再运行(等待服务进程与tailscale服务器连接)
            ```

            📦 **附带文件**：
            | 文件名               | 说明                  |
            |----------------------|-----------------------|
            | tailscaled-linux-ARCH    | 不同架构已压缩的可执行文件 |
            | tailscaled-linux-ARCH.build | 不同架构未压缩的可执行文件 |
            | SHA256SUMS.txt        | SHA256 校验文件        |
            | MD5SUMS.txt           | MD5 校验文件           |
            | version.txt           | 当前版本          |

            📜 **更新日志**：
            [点此查看](https://tailscale.com/changelog)

          draft: false
          prerelease: false
          files: |
            ./build/tailscaled-*
            ./upx_compress/tailscaled-*
            version.txt
            SHA256SUMS.txt
            MD5SUMS.txt